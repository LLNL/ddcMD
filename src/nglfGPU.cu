#include "nglfGPU.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/times.h>
#include <unistd.h>
#include <math.h>
#include "three_algebra.h"
#include "object.h"
#include "ddc.h"
#include "box.h"
#include "species.h"
#include "ddcMalloc.h"
#include "ddcenergy.h"
#include "expandbuffer.h"
#include "auxNeighbor.h"
#include "preduce.h"
#include "group.h"
#include "energyInfo.h"
#include "cudaUtils.h"
#include "langevin.h"
#include <curand_kernel.h>
#include "cudaTypes.h"
#include "codata.h"
#include "pairProcessGPU.h"
#include "molecularPressureGPU.h"

//void kinetic_terms(SYSTEM*sys, int flag);
//void eval_energyInfo(SYSTEM *sys);
void nglf_collision(SYSTEM *sys, double dt);
double pair_function(SYSTEM *sys, int i, int j, double r, double *dr);

typedef struct ref_str
{
    THREE_VECTOR r, v;
} REF;
REF *vaf_v0(void);
//static AUXNEIGHBOR  *auxNeighbor ; 

NGLFGPU_PARMS *nglf_parms(INTEGRATOR*integrator)
{
    NGLFGPU_PARMS *parms;
    parms = (NGLFGPU_PARMS*) ddcMalloc(sizeof (NGLFGPU_PARMS));
    //parms->acc = NULL; 
    //double rmax = 3.0; 
    //auxNeighbor = auxNeighbor_request(rmax); 

    return parms;
}

void scalePositionsByBoxChange(BOX_STRUCT *box, double time, double *rx, double *ry, double *rz, unsigned nlocal)
{
    THREE_MATRIX hfac;
    THREE_VECTOR rold, r;
    box_put(box, BOX_TIME, (void *) &time);
    box_get(box, HFAC, (void *) &hfac);
    if (!matrix_equal(hfac, I_3x3))
    {
        for (unsigned kk = 0; kk < nlocal; kk++)
        {
            rold.x = rx[kk];
            rold.y = ry[kk];
            rold.z = rz[kk];
            r = matrix_vector(hfac, rold);
            rx[kk] = r.x;
            ry[kk] = r.y;
            rz[kk] = r.z;

        }
    }
}

void updateStateAliases(SYSTEM *sys, unsigned *nlocal, double **rx, double **ry, double **rz, double **vx, double **vy, double **vz, double **fx, double **fy, double **fz, SPECIES ***species, gid_type **label)
{
    STATE *state = sys->collection->state;
    *nlocal = sys->nlocal;
    *rx = state->rx;
    *ry = state->ry;
    *rz = state->rz; // The SYSTEM and STATE might change during the call to ddcenergy
    *vx = state->vx;
    *vy = state->vy;
    *vz = state->vz; // (i.e., we might reassign particles to new tasks) so we need to
    *fx = state->fx;
    *fy = state->fy;
    *fz = state->fz; // update all of the aliases we use.
    *label = state->label;
    *species = state->species;
}

__global__ void freeVelocityUpdateGPU(int *species, double *mass, STATE *state, int nlocal, double dt)
{

    int pid = blockIdx.x * blockDim.x + threadIdx.x;
    //int tid = threadIdx.x;
    if (pid >= nlocal)
    {
        return;
    }

    double *vx = state->vx;
    double *vy = state->vy;
    double *vz = state->vz;
    double *fx = state->fx;
    double *fy = state->fy;
    double *fz = state->fz;

    int speciesID = species[pid];
    double a = dt / mass[speciesID];
    vx[pid] += fx[pid] * a;
    vy[pid] += fy[pid] * a;
    vz[pid] += fz[pid] * a;
    //printf("pid %i vx %f fx %f\n", pid, vx[pid], fx[pid]);
}

__global__ void freeVelocityUpdateInterleavedGPU(int *species, int *rback, double *forceBuffer, double *mass, STATE *state, int nlocal, double dt)
{

    int pid = blockIdx.x * blockDim.x + threadIdx.x;
    //int tid = threadIdx.x;
    if (pid >= nlocal)
    {
        return;
    }

    double *vx = state->vx;
    double *vy = state->vy;
    double *vz = state->vz;
    double *fx = state->fx;
    double *fy = state->fy;
    double *fz = state->fz;

    int ii = pid; //rback[pid];
    int speciesID = species[pid];
    double a = dt / mass[speciesID];
    vx[pid] += (forceBuffer[7 * ii + 1] + fx[pid]) * a;
    vy[pid] += (forceBuffer[7 * ii + 2] + fy[pid]) * a;
    vz[pid] += (forceBuffer[7 * ii + 3] + fz[pid]) * a;
    //printf("pid %i vx %f fx %f\n", pid, vx[pid], fx[pid]);
}

__global__ void freePositionUpdateGPU(STATE *state, int nlocal, double dt)
{

    int pid = blockIdx.x * blockDim.x + threadIdx.x;
    //int tid = threadIdx.x;
    if (pid >= nlocal)
    {
        return;
    }

    double *rx = state->rx;
    double *ry = state->ry;
    double *rz = state->rz;
    double *vx = state->vx;
    double *vy = state->vy;
    double *vz = state->vz;

    rx[pid] += vx[pid] * dt;
    ry[pid] += vy[pid] * dt;
    rz[pid] += vz[pid] * dt;
    //printf("pid %i rx %f\n", pid, rx[pid]);
}

/* Langevin Velocity Update
 * state: gpu state
 * tau: single tau values
 * kBT: kB * Teq //is Teq ideal temperature or instantaneous temp? 
 * mass: array of species masses
 * nlocal: number of local particles
 * dt: time step
 * vcm: velocity center
 * random: random number arrays generated by curand 
 */
__global__ void langevin_velocityUpdateGPU_FrontTimestep(int* species, STATE *state, double tau, double kBT, double *mass, int nlocal, double dt, double vcmx, double vcmy, double vcmz, double *randomx, double *randomy, double *randomz)
{

    int pid = blockIdx.x * blockDim.x + threadIdx.x;
    if (pid < nlocal)
    {
        double *vx = state->vx;
        double *vy = state->vy;
        double *vz = state->vz;
        double *fx = state->fx;
        double *fy = state->fy;
        double *fz = state->fz;

        int speciesID = species[pid];
        //double mass = mass[speciesID];

        //get vcm and store as v 
        // double vcmx;
        // double vcmy;
        //double vcmz;

        //get tau and kbT (may not need array...) 
        //      double mykBT = kBT[pid*stridekBT];
        //      double myTau = tau[pid*strideTau];

        //coefficents
        double a = exp(-dt / tau);
        //double c = dt/mass; 
        double c = dt / mass[speciesID];
        //double d = sqrt(2.0*dt*kBT/(mass*tau)); 
        double d = sqrt(2.0 * dt * kBT / (mass[speciesID] * tau));
        //get random number
        double gx = (double) randomx[pid];
        double gy = (double) randomy[pid];
        double gz = (double) randomz[pid];
        //double vxold = vx[pid];
        //calculate Front Timestep
        vx[pid] = vcmx + a * (vx[pid] - vcmx) + c * fx[pid] + d*gx;
        vy[pid] = vcmy + a * (vy[pid] - vcmy) + c * fy[pid] + d*gy;
        vz[pid] = vcmz + a * (vz[pid] - vcmz) + c * fz[pid] + d*gz;
        //if (pid<10) printf("gi %i a %f c %f d %f vcm %f fx %f vxold %f vxnew %f\n", pid,a,c,d,vcmx,fx[pid], vxold, vx[pid]);
    } //end if
}

/* Langevin Velocity Update Interleaved force energy buffer
 * state: gpu state
 * tau: single tau values
 * kBT: kB * Teq //is Teq ideal temperature or instantaneous temp? 
 * mass: array of species masses
 * nlocal: number of local particles
 * dt: time step
 * vcm: velocity center
 * random: random number arrays generated by curand 
 */
__global__ void langevin_velocityUpdateGPUInterleaved_FrontTimestep(int* species, STATE *state, double *forceBuffer, double tau, double kBT, double *mass, int nlocal, double dt, double vcmx, double vcmy, double vcmz, double *randomx, double *randomy, double *randomz)
{

    int pid = blockIdx.x * blockDim.x + threadIdx.x;
    if (pid < nlocal)
    {
        double *vx = state->vx;
        double *vy = state->vy;
        double *vz = state->vz;
        double *fx = state->fx;
        double *fy = state->fy;
        double *fz = state->fz;

        int speciesID = species[pid];
        //double mass = mass[speciesID];

        //get vcm and store as v 
        // double vcmx;
        // double vcmy;
        //double vcmz;

        //get tau and kbT (may not need array...) 
        //      double mykBT = kBT[pid*stridekBT];
        //      double myTau = tau[pid*strideTau];

        //coefficents
        double a = exp(-dt / tau);
        //double c = dt/mass; 
        double c = dt / mass[speciesID];
        //double d = sqrt(2.0*dt*kBT/(mass*tau)); 
        double d = sqrt(2.0 * dt * kBT / (mass[speciesID] * tau));
        //get random number
        double gx = (double) randomx[pid];
        double gy = (double) randomy[pid];
        double gz = (double) randomz[pid];
        //double vxold = vx[pid];
        //calculate Front Timestep
        vx[pid] = vcmx + a * (vx[pid] - vcmx) + c * (fx[pid] + forceBuffer[7 * pid + 1]) + d*gx;
        vy[pid] = vcmy + a * (vy[pid] - vcmy) + c * (fy[pid] + forceBuffer[7 * pid + 2]) + d*gy;
        vz[pid] = vcmz + a * (vz[pid] - vcmz) + c * (fz[pid] + forceBuffer[7 * pid + 3]) + d*gz;
        //if (pid<10) printf("gi %i a %f c %f d %f vcm %f fx %f vxold %f vxnew %f\n", pid,a,c,d,vcmx,fx[pid], vxold, vx[pid]);
    } //end if
}

__global__ void langevin_velocityUpdateGPUInterleaved_BackTimestep(int *species, STATE *state, double *forceBuffer, double tau, double kBT, double *mass, int nlocal, double dt, double vcmx, double vcmy, double vcmz, double *randomx, double *randomy, double *randomz)
{

    int pid = blockIdx.x * blockDim.x + threadIdx.x;
    if (pid < nlocal)
    {

        double *vx = state->vx;
        double *vy = state->vy;
        double *vz = state->vz;
        double *fx = state->fx;
        double *fy = state->fy;
        double *fz = state->fz;

        int speciesID = species[pid];
        //      double mass = mass[speciesID];

        //get vcm and store as v 
        //double vcmx;
        //double vcmy;
        //double vcmz;

        //get tau and kbT (may not need array...) 
        //      double mykBT = kBT[pid*stridekBT];
        //      double myTau = tau[pid*strideTau];

        //coefficents
        double a = exp(-dt / tau);
        //double c = dt/mass; 
        double c = dt / mass[speciesID];
        //double d = sqrt(2.0*dt*kBT/(mass*tau)); 
        double d = sqrt(2.0 * dt * kBT / (mass[speciesID] * tau));
        //get random number
        double gx = (double) randomx[pid];
        double gy = (double) randomy[pid];
        double gz = (double) randomz[pid];

        //double vxold = vx[pid];
        //calculate Front Timestep
        vx[pid] = vcmx + a * ((vx[pid] - vcmx) + c * (fx[pid] + forceBuffer[7 * pid + 1]) + d * gx);
        vy[pid] = vcmy + a * ((vy[pid] - vcmy) + c * (fy[pid] + forceBuffer[7 * pid + 2]) + d * gy);
        vz[pid] = vcmz + a * ((vz[pid] - vcmz) + c * (fz[pid] + forceBuffer[7 * pid + 3]) + d * gz);
        //if (pid<10) printf("gib %i a %f c %f d %f vcm %f fx %f vxold %f vxnew %f\n", pid,a,c,d,vcmx,fx[pid], vxold, vx[pid]);
    } //end if
}

__global__ void langevin_velocityUpdateGPU_BackTimestep(int *species, STATE *state, double tau, double kBT, double *mass, int nlocal, double dt, double vcmx, double vcmy, double vcmz, double *randomx, double *randomy, double *randomz)
{

    int pid = blockIdx.x * blockDim.x + threadIdx.x;
    if (pid < nlocal)
    {

        double *vx = state->vx;
        double *vy = state->vy;
        double *vz = state->vz;
        double *fx = state->fx;
        double *fy = state->fy;
        double *fz = state->fz;

        int speciesID = species[pid];
        //      double mass = mass[speciesID];

        //get vcm and store as v 
        //double vcmx;
        //double vcmy;
        //double vcmz;

        //get tau and kbT (may not need array...) 
        //      double mykBT = kBT[pid*stridekBT];
        //      double myTau = tau[pid*strideTau];

        //coefficents
        double a = exp(-dt / tau);
        //double c = dt/mass; 
        double c = dt / mass[speciesID];
        //double d = sqrt(2.0*dt*kBT/(mass*tau)); 
        double d = sqrt(2.0 * dt * kBT / (mass[speciesID] * tau));
        //get random number
        double gx = (double) randomx[pid];
        double gy = (double) randomy[pid];
        double gz = (double) randomz[pid];

        //double vxold = vx[pid];
        //calculate Front Timestep
        vx[pid] = vcmx + a * ((vx[pid] - vcmx) + c * fx[pid] + d * gx);
        vy[pid] = vcmy + a * ((vy[pid] - vcmy) + c * fy[pid] + d * gy);
        vz[pid] = vcmz + a * ((vz[pid] - vcmz) + c * fz[pid] + d * gz);
        //if (pid<10) printf("gib %i a %f c %f d %f vcm %f fx %f vxold %f vxnew %f\n", pid,a,c,d,vcmx,fx[pid], vxold, vx[pid]);
    } //end if
}

void nglfGPULangevinOLD(DDC*ddc, SIMULATE*simulate, NGLFGPU_PARMS*p) 
{
    double dt = simulate->dt;
    double time = simulate->time;
    SYSTEM* sys = simulate->system;
    GPUNLIST *gnlist=sys->collection->gnlist;
    COLLECTION *collection = sys->collection;
    STATE* state = sys->collection->state;
    unsigned nlocal;
    double *rx, *ry, *rz, *vx, *vy, *vz, *fx, *fy, *fz;
    SPECIES** species;
    LONG64* label;
    updateStateAliases(sys, &nlocal, &rx, &ry, &rz, &vx, &vy, &vz, &fx, &fy, &fz, &species, &label);

    int blockSize = min(64, nlocal);
    int gridSize = ceil((float) nlocal / blockSize);
    //get random numbers
    unsigned nrandom = nlocal;
    if (nrandom % 2 != 0) nrandom++;
    curandGenerateNormalDouble(gnlist->gpu_types->gen, gnlist->gpuRandomx, nrandom, 0.0, 1.0);
    curandGenerateNormalDouble(gnlist->gpu_types->gen, gnlist->gpuRandomy, nrandom, 0.0, 1.0);
    curandGenerateNormalDouble(gnlist->gpu_types->gen, gnlist->gpuRandomz, nrandom, 0.0, 1.0);

    GROUP *group = state->group[0];
    LANGEVIN_PARMS *lp = (LANGEVIN_PARMS *) group->parm;

    THREE_VECTOR vcm = lp->vcm;
    double tau = lp->tau[0];
    double kBT = lp->kBT[0];

    //Front Timestep 

    langevin_velocityUpdateGPU_FrontTimestep<<<gridSize, blockSize>>>(gnlist->species_g, collection->gpustate, tau, kBT, gnlist->mass_g, nlocal, 0.5 * dt, vcm.x, vcm.y, vcm.z, gnlist->gpuRandomx, gnlist->gpuRandomy, gnlist->gpuRandomz);

    freePositionUpdateGPU<<<gridSize, blockSize>>>(collection->gpustate, nlocal, dt);

    //double time_plus_dt = time + dt; 
    ddc->update = 0;
    time += dt; // positions, box (volume, h0,hinv) , and forces at  t = n*dt + dt 
    simulate->time = sys->time = time;
    simulate->loop++;
    sys->loop = simulate->loop;
    if (ddcenergy(ddc, sys, 0) != 0) return;
    updateStateAliases(sys, &nlocal, &rx, &ry, &rz, &vx, &vy, &vz, &fx, &fy, &fz, &species, &label);

    //get new random numbers and do back timestep
    curandGenerateNormalDouble(gnlist->gpu_types->gen, gnlist->gpuRandomx, nrandom, 0.0, 1.0);
    curandGenerateNormalDouble(gnlist->gpu_types->gen, gnlist->gpuRandomy, nrandom, 0.0, 1.0);
    curandGenerateNormalDouble(gnlist->gpu_types->gen, gnlist->gpuRandomz, nrandom, 0.0, 1.0);

    langevin_velocityUpdateGPU_BackTimestep<<<gridSize, blockSize>>>(gnlist->species_g, collection->gpustate, tau, kBT, gnlist->mass_g, nlocal, 0.5 * dt, vcm.x, vcm.y, vcm.z, gnlist->gpuRandomx, gnlist->gpuRandomy, gnlist->gpuRandomz);

    simulate->time = sys->time = time;
}

//void nglfconstraintGPULangevin(DDC *ddc, SIMULATE *simulate, NGLFGPU_PARMS *p)

void nglfGPULangevin(DDC*ddc, SIMULATE*simulate, NGLFGPU_PARMS*p) 
{
    PUSH_RANGE("timestep", 4);
    double dt = simulate->dt;
    double time = simulate->time;
    SYSTEM* sys = simulate->system;
    GPUNLIST *gnlist=sys->collection->gnlist;
    STATE* state = sys->collection->state;
    //STATE* gsh = sys->collection->gpustate_h;
    COLLECTION *collection = sys->collection;
    unsigned nlocal = state->nlocal;
    double *rx, *ry, *rz, *vx, *vy, *vz, *fx, *fy, *fz;
    SPECIES** species;
    LONG64* label;

    calcMolecularPressuresGPU(sys);

    calcTensorWithGPUVirials(sys, &sys->energyInfo);

    THREE_SMATRIX pTensor = (sys->energyInfo.virial);

    //printf("pTensor %f %f %f\n", pTensor.xx, pTensor.yy, pTensor.zz);
    int N = sys->moleculeClass->nMoleculesGlobal;
    double vol = box_get_volume(NULL);
    double T = p->T;
    pTensor.xx += N * kB*T;
    pTensor.yy += N * kB*T;
    pTensor.zz += N * kB*T;
    SMATNORM(pTensor, vol);
    pTensor.xx -= p->P0;
    pTensor.yy -= p->P0;
    pTensor.zz -= p->P0;

    //printf("gpu pTensor %.15f %.15f %.15f\n\n", pTensor.xx, pTensor.yy, pTensor.zz);

    changeVolumeGPUisotropic(collection, collection->gpustate, sys->box, &pTensor, p->beta, p->tauBarostat, dt, sys->nlocal);

    //get random numbers
    PUSH_RANGE("random gen", 3);
    unsigned nrandom = nlocal;
    if (nrandom % 2 != 0) nrandom++;

    curandGenerateNormalDouble(gnlist->gpu_types->gen, gnlist->gpuRandomx, nrandom, 0.0, 1.0);
    curandGenerateNormalDouble(gnlist->gpu_types->gen, gnlist->gpuRandomy, nrandom, 0.0, 1.0);
    curandGenerateNormalDouble(gnlist->gpu_types->gen, gnlist->gpuRandomz, nrandom, 0.0, 1.0);
    POP_RANGE();

    GROUP* group0 = state->group[0];
    LANGEVIN_PARMS *lp = (LANGEVIN_PARMS*) group0->parm;
    THREE_VECTOR vcm = lp->vcm;
    double tau = lp->tau[0];
    double kBT = lp->kBT[0];

    int blockSize = min(64, state->nlocal);
    //int gridSize = (state->nlocal+blockSize-1)/blockSize;
    int gridSize = ceil((float) state->nlocal / blockSize);
    //freeVelocityUpdateGPU<<<gridSize, blockSize>>>(gnlist->species_g, gnlist->mass_g, collection->gpustate, state->nlocal, .5*dt);
    langevin_velocityUpdateGPUInterleaved_FrontTimestep<<<gridSize, blockSize>>>(gnlist->species_g, collection->gpustate, gnlist->results, tau, kBT, gnlist->mass_g, state->nlocal, .5 * dt, vcm.x, vcm.y, vcm.z, gnlist->gpuRandomx, gnlist->gpuRandomy, gnlist->gpuRandomz);

    updateStateAliasesGPU(sys, &nlocal, &rx, &ry, &rz, &vx, &vy, &vz, &fx, &fy, &fz, &species, &label);
    freePositionUpdateGPU<<<gridSize, blockSize>>>(collection->gpustate, state->nlocal, dt);

    CUDA_SAFE_CALL(cudaPeekAtLastError();)
    //double time_plus_dt = time + dt; 

    ddc->update = 0;
    time += dt; // positions, box (volume, h0,hinv) , and forces at  t = n*dt + dt 
    simulate->time = sys->time = time;
    simulate->loop++;
    sys->loop = simulate->loop;

    if (ddcenergy(ddc, sys, 0) != 0) return;

    curandGenerateNormalDouble(gnlist->gpu_types->gen, gnlist->gpuRandomx, nrandom, 0.0, 1.0);
    curandGenerateNormalDouble(gnlist->gpu_types->gen, gnlist->gpuRandomy, nrandom, 0.0, 1.0);
    curandGenerateNormalDouble(gnlist->gpu_types->gen, gnlist->gpuRandomz, nrandom, 0.0, 1.0);

    vcm = lp->vcm;
    updateStateAliasesGPU(sys, &nlocal, &rx, &ry, &rz, &vx, &vy, &vz, &fx, &fy, &fz, &species, &label);
    langevin_velocityUpdateGPUInterleaved_BackTimestep<<<gridSize, blockSize>>>(gnlist->species_g, collection->gpustate, gnlist->results, tau, kBT, gnlist->mass_g, state->nlocal, .5 * dt, vcm.x, vcm.y, vcm.z, gnlist->gpuRandomx, gnlist->gpuRandomy, gnlist->gpuRandomz);
    //freeVelocityUpdateGPU<<<gridSize, blockSize>>>(gnlist->species_g, gnlist->mass_g, gnlist->gpustate,nlocal, .5*dt);
    CUDA_SAFE_CALL(cudaPeekAtLastError();)

    //kineticGPU(sys, 1);
    simulate->time = sys->time = time;
    POP_RANGE();

}

void nglfGPU(DDC*ddc, SIMULATE*simulate, NGLFGPU_PARMS*p) 
{
    double dt = simulate->dt;
    double time = simulate->time;
    SYSTEM* sys = simulate->system;
    GPUNLIST *gnlist=sys->collection->gnlist;
    STATE* state = sys->collection->state;
    COLLECTION *collection = sys->collection;
    unsigned nlocal;
    double *rx, *ry, *rz, *vx, *vy, *vz, *fx, *fy, *fz;
    SPECIES** species;
    LONG64* label;
    updateStateAliases(sys, &nlocal, &rx, &ry, &rz, &vx, &vy, &vz, &fx, &fy, &fz, &species, &label);
    //scalePositionsByBoxChange(sys->box,time,rx,ry,rz,nlocal); 
    /*
    for (unsigned kk=0; kk<nlocal; kk++) 
    {
       GROUP* group = state->group[kk]; 
       group->velocityUpdate(FRONT_TIMESTEP,kk,group,state,time,0.5*dt);
    }
     */
    //for (int k =0;k<nlocal;k++)
    //  printf("c i %i v %f\n", k,state->vx[k]);
    int blockSize = min(64, nlocal);
    int gridSize = ceil((float) nlocal / blockSize);
    //printf("first velocity update\n");

    //get random numbers
    /*   curandGenerateUniform(gnlist->gpu_types->gen, gnlist->gpuRandomx, nlocal); 
       curandGenerateUniform(gnlist->gpu_types->gen, gnlist->gpuRandomy, nlocal); 
       curandGenerateUniform(gnlist->gpu_types->gen, gnlist->gpuRandomz, nlocal); 

       GROUP *group = state->group[0];
       LANGEVIN_PARMS *lp=(LANGEVIN_PARMS *)group->parm;

       THREE_VECTOR vcm = lp->vcm;
       double tau = lp->tau[0];
       double kBT = lp->kBT[0];

       //Front Timestep 
       langevin_velocityUpdateGPU_FrontTimestep<<<gridSize, blockSize>>>(gnlist->species_g, state, tau, kBT, gnlist->mass_g, nlocal, 0.5*dt, vcm.x, vcm.y, vcm.z, gnlist->gpuRandomx, gnlist->gpuRandomy, gnlist->gpuRandomz);
     */


    //sendGPUState(sys, nlocal);
    //sendForceVelocityToGPU(sys, nlocal);
    //freeVelocityUpdateGPU<<<gridSize, blockSize>>>(gnlist->species_g, gnlist->mass_g, collection->gpustate, nlocal, .5*dt);

    freeVelocityUpdateInterleavedGPU<<<gridSize, blockSize>>>(gnlist->species_g, gnlist->listIdsg, gnlist->results, gnlist->mass_g, collection->gpustate, state->nlocal, .5 * dt);
    //freeVelocityUpdateInterleavedGPU<<<gridSize, blockSize>>>(gnlist->species_g, gnlist->results,gnlist->mass_g, collection->gpustate, nlocal, .5*dt);
    //sendForceVelocityToHost(sys, nlocal);
    //REF *v0 = vaf_v0();
    /* 
   for (unsigned kk = 0; kk < nlocal; kk++)
   {
      THREE_VECTOR delta; 
      rx[kk] += delta.x = dt*vx[kk];
      ry[kk] += delta.y = dt*vy[kk];
      rz[kk] += delta.z = dt*vz[kk];
      //if (v0 != NULL )  VOP1(v0[kk].r,+=,delta); 
   }*/

    //sendGPUState(sys, nlocal);
    freePositionUpdateGPU<<<gridSize, blockSize>>>(collection->gpustate, nlocal, dt);
    // sendHostState(sys, nlocal);

    //double time_plus_dt = time + dt; 
    //scalePositionsByBoxChange(sys->box,time_plus_dt,rx,ry,rz,nlocal); 
    //for (unsigned kk = 0; kk < nlocal; kk++) backInBox_fast(rx + kk, ry + kk, rz + kk);
    ddc->update = 0;
    time += dt; // positions, box (volume, h0,hinv) , and forces at  t = n*dt + dt 
    simulate->time = sys->time = time;
    simulate->loop++;
    sys->loop = simulate->loop;
    //for (int kk=0;kk<sys->ngroup;kk++) sys->group[kk]->Update1(sys->group[kk],-1,state,time,0.5*dt);
    if (ddcenergy(ddc, sys, 0) != 0) return;
    updateStateAliases(sys, &nlocal, &rx, &ry, &rz, &vx, &vy, &vz, &fx, &fy, &fz, &species, &label);
    //for (int kk=0;kk<sys->ngroup;kk++) sys->group[kk]->Update(sys->group[kk],BACK_TIMESTEP,state,time,0.5*dt);
    /*
    for (unsigned kk=0;kk<nlocal;kk++) 
    {
       GROUP* group = state->group[kk]; 
       group->velocityUpdate(BACK_TIMESTEP,kk,group,state,time,0.50*dt);
    }
     */
    //sendForceVelocityToGPU(sys, nlocal);
    //freeVelocityUpdateGPU<<<gridSize, blockSize>>>(gnlist->species_g, gnlist->mass_g, collection->gpustate,nlocal, .5*dt);

    freeVelocityUpdateInterleavedGPU<<<gridSize, blockSize>>>(gnlist->species_g, gnlist->listIdsg, gnlist->results, gnlist->mass_g, collection->gpustate, state->nlocal, .5 * dt);
    //sendForceVelocityToHost(sys, nlocal);
    //sendHostState(sys, sys->nlocal);
    //sendForceVelocityToHost(sys, sys->nlocal);
    //kinetic_terms(sys, 1);
    //for (int kk=0;kk<sys->ngroup;kk++) sys->group[kk]->Update2(sys->group[kk],-1,state,time,0.5*dt);
    //eval_energyInfo(sys);
    //for (int kk=0;kk<sys->ngroup;kk++) sys->group[kk]->Update(sys->group[kk],FRONT_TIMESTEP,state,time,0.5*dt);

    /*errorCheck(ddc->domain_id, simulate->loop, state, sys->energyInfo, p, datafile); */
    simulate->time = sys->time = time;
}


/* Local Variables: */
/* tab-width: 3 */
/* End: */
